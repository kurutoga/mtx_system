<html>
<body>
<pre>
           CS460 LAB#3: DUE Week of 9-21-2015

1. Given the following ts.s file for the MTX kernel. 

        MTXSEG  = 0x1000
	
       .globl _main,_running,_scheduler
       .globl _proc, _procSize
       .globl _tswitch
	
        jmpi   start,MTXSEG

start:	mov  ax,cs
	mov  ds,ax
	mov  ss,ax
        mov  es,ax
	mov  sp,#_proc
	add  sp,_procSize
		
	call _main

_tswitch:
SAVE:	
	push ax
	push bx
	push cx
	push dx
	push bp
	push si
	push di
	pushf
	mov  bx,_running
	mov  2[bx],sp

FIND:	call _scheduler

RESUME:
	mov  bx,_running
	mov  sp,2[bx]
	popf
	pop  di
	pop  si
	pop  bp
	pop  dx
	pop  cx
	pop  bx
	pop  ax

	ret

	
! added functions for KUMODE
	.globl _int80h,_goUmode,_kcinth
!These offsets are defined in struct proc
USS =   4
USP =   6

_int80h:
        push bp
        push si
        push di
        push es
        push ds


        push cs
        pop  ds                 ! KDS now

	mov si,_running  	! ready to access proc
        mov USS[si],ss          ! save uSS  in proc.USS
        mov USP[si],sp          ! save uSP  in proc.USP

! Change ES,SS to kernel segment
        mov  di,ds              ! stupid !!        
        mov  es,di              ! CS=DS=SS=ES in Kmode
        mov  ss,di

! set sp to HI end of running's kstack[]
	mov  sp,_running        ! proc's kstack [2 KB]
        add  sp,_procSize       ! HI end of PROC

        call  _kcinth
        jmp   _goUmode
  
_goUmode:
        cli
	mov bx,_running 	! bx -> proc
        mov cx,USS[bx]
        mov ss,cx               ! restore uSS
        mov sp,USP[bx]          ! restore uSP
  
	pop ds
	pop es
	pop di
        pop si
        pop bp

        iret
!----------------- end of ts.s file -----------------------------

The ts.s file is ALMOST identical to the ts.s file on Page 138 of the TEXT, 
except in
 
_int80h:
        there are NO push ax,bx,cx,dx
_goUmode:
        there are NO pop  dx,cx,bx,ax
!----------------------------------------------------------------


2. YOUR OWN wait.c file containing
int ksleep(int event)
{
  // caller goes to SLEEP on event
}

int kwakeup(int event)
{
  // wakeup ALL procs sleeping on event
}

int kexit(int exitValue)
{
  // caller becomes a ZOMBIE with an exitValue in its PROC
  // (of course, give away children, if any, and wakeup parent and/or P1)
}

int kwait(int *status)
{
  // caller waits for a ZOMBIE child
}
==================================================================

3. YOUR OWN kernel.c file containing

PROC *kfork(char *filename)
{
  kfork() creates a child process ready to run in Kmode but
  with a Umode image "filename" loaded to its segment AND
  ready to go back to Umode to execute the Umode image.
}

int body()
{
  char c;
  printf("proc %d resumes to body()\n", running->pid);
  while(1){
    printf("-----------------------------------------\n");
    print freeList
    print readyQueue
    printf("-----------------------------------------\n");

    printf("proc %d running: parent = %d  enter a char [s|f|w|q|u] : ", 
	   running->pid, running->parent->pid);
    c = getc(); printf("%c\n", c);
    switch(c){
       //----------------------------------------
       case 's' : do_tswitch();   break;
       case 'f' : do_kfork();     break;
       case 'w' : do_wait();      break;
       case 'q' : do_exit();      break;
    //--- above commands are same as in LAB#2. The 'u' command is NEW -------

       case 'u' : goUmode();      break; // <=== go back to Umode
    }
  }
}

int do_ps()
{
  print ALL proc information, i.e. name, pid, ppid, status
}
int chname(char *newname)
{
  change process name to newname
} 
==============================================================

4. YOUR OWN int.c file as on Page 148 of TEXT 
   (adjusted per the int80h() interrupt handler code in the NEW ts.s)

5. The following t.c file for the MTX kernel

typedef unsigned char   u8;
typedef unsigned short u16;
typedef unsigned long  u32;

#define NULL     0
#define NPROC    9
#define SSIZE 1024

//******* PROC status ********
#define FREE     0
#define READY    1
#define RUNNING  2
#define STOPPED  3
#define SLEEP    4
#define ZOMBIE   5

typedef struct proc{
    struct proc *next;
    int    *ksp;

    int    uss, usp;
    int    pid;                // add pid for identify the proc
    int    status;             // status = FREE|READY|RUNNING|SLEEP|ZOMBIE    
    int    ppid;               // parent pid
    struct proc *parent;
    int    priority;
    int    event;
    int    exitCode;

    char   name[32];
    int    kstack[SSIZE];      // per proc stack area
}PROC;

PROC proc[NPROC], *running, *freeList, *readyQueue, *sleepList;
int procSize = sizeof(PROC);

int body();
char *pname[]={"Sun", "Mercury", "Venus", "Earth",  "Mars", "Jupiter", 
               "Saturn", "Uranus", "Neptune" };

/**************************************************
  I/O , queue functions and load() are in mtxlib
**************************************************/
#include "wait.c"          // YOUR OWN wait.c file:
#include "kernel.c"        // YOUR OWN kernel.c file
#include "int.c"           // YOUR OWN int.c file

int init()
{
    PROC *p; int i;
    printf("init ....");
    for (i=0; i < NPROC; i++){   // initialize all procs
        p = &proc[i];
        p->pid = i;
        p->status = FREE;
        p->priority = 0;  
        strcpy(proc[i].name, pname[i]);
   
        p->next = &proc[i+1];
    }
    freeList = &proc[0];      // all procs are in freeList
    proc[NPROC-1].next = 0;
    readyQueue = sleepList = 0;

    /**** create P0 as running ******/
    p = get_proc(&freeList);
    p->status = READY;
    p->ppid   = 0;
    p->parent = p;
    running = p;
    printf("done\n");
} 

int scheduler()
{
    if (running->status == READY){
       enqueue(&readyQueue, running);
    }
    running = dequeue(&readyQueue);
}

int int80h();

int set_vec(u16 vector, u16 handler)
{
  // put_word(word, segment, offset) in mtxlib
     put_word(handler, 0, vector<<2);
     put_word(0x1000,  0, (vector<<2) + 2);
}
            
main()
{
    printf("MTX starts in main()\n");
    init();      // initialize and create P0 as running
    set_vec(80, int80h);

    kfork("/bin/u1");     // P0 kfork() P1

    while(1){
      printf("P0 running\n");
      while(!readyQueue);
      printf("P0 switch process\n");
      tswitch();   // P0 switch to run P1
   }
}
=================================================================
6. mk script to compile-link MTX kernel image

VFD=FDimage    # donwload FDimage file from samples/LAB3

as86 -o ts.o ts.s
bcc  -c -ansi t.c
ld86 -d -o mtx ts.o t.o mtxlib /usr/lib/bcc/libc.a

mount -o loop $VFD /mnt
cp mtx /mnt/boot
umount /mnt

(cd USER; mku u1)

echo done
==================================================================

7. User Mode Image files: Download 
   Run mku u1 to create a /bin/u1 Umode image file
=================================================================

                REQUIREMENTS:

1. With the MODIFIED ts.s file, write YOUR 
        kfork() function
        kcinth() function
   to make the MTX system still work.

2. In Umode, getc(), putc() are in mtxlib, which use BIOS. 
   Change getc(), putc() in Umode to system calls to the MTX kernel.
   
   getc(): syscall # = 7
   putc(): syscall # = 8

